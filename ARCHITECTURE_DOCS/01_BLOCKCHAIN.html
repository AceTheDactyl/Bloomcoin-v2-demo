<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BloomCoin Blockchain Module: Mathematical Foundations | BloomCoin v2 Architecture</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a24;
            --text-primary: #e0e0e0;
            --text-muted: #808080;
            --accent-gold: #ffd700;
            --accent-cyan: #00ffff;
            --accent-magenta: #ff00ff;
            --accent-green: #44ff44;
            --accent-orange: #ff8844;
            --accent-blue: #4488ff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.7;
        }

        .nav-header {
            background: var(--bg-secondary);
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--bg-tertiary);
            position: sticky;
            top: 0;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-brand {
            color: var(--accent-gold);
            text-decoration: none;
            font-weight: 700;
            font-size: 1.1rem;
        }

        .nav-links {
            display: flex;
            gap: 1.5rem;
        }

        .nav-links a {
            color: var(--text-muted);
            text-decoration: none;
            font-size: 0.85rem;
            transition: color 0.3s ease;
        }

        .nav-links a:hover {
            color: var(--accent-cyan);
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 3rem 2rem;
        }

        h1 {
            font-size: 2.2rem;
            color: var(--accent-gold);
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--accent-gold);
        }

        h2 {
            font-size: 1.6rem;
            color: var(--accent-cyan);
            margin-top: 2.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--bg-tertiary);
        }

        h3 {
            font-size: 1.3rem;
            color: var(--accent-magenta);
            margin-top: 2rem;
            margin-bottom: 0.75rem;
        }

        h4 {
            font-size: 1.1rem;
            color: var(--accent-green);
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
        }

        p {
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        a {
            color: var(--accent-cyan);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        .code-block {
            background: var(--bg-secondary);
            border: 1px solid var(--bg-tertiary);
            border-radius: 0.5rem;
            padding: 1rem;
            overflow-x: auto;
            margin: 1rem 0;
            position: relative;
        }

        .code-block::before {
            content: attr(data-lang);
            position: absolute;
            top: 0.5rem;
            right: 0.75rem;
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .code-block code {
            color: var(--accent-green);
            font-size: 0.85rem;
        }

        .inline-code {
            background: var(--bg-secondary);
            color: var(--accent-orange);
            padding: 0.15rem 0.4rem;
            border-radius: 0.25rem;
            font-size: 0.9em;
        }

        ul, ol {
            margin: 1rem 0;
            padding-left: 1.5rem;
        }

        li {
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        li::marker {
            color: var(--accent-cyan);
        }

        .table-wrapper {
            overflow-x: auto;
            margin: 1.5rem 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: var(--bg-secondary);
            border-radius: 0.5rem;
            overflow: hidden;
        }

        th {
            background: var(--bg-tertiary);
            color: var(--accent-gold);
            padding: 0.75rem 1rem;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid var(--accent-gold);
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--bg-tertiary);
            color: var(--text-primary);
        }

        tr:hover td {
            background: var(--bg-tertiary);
        }

        blockquote {
            border-left: 3px solid var(--accent-magenta);
            padding-left: 1rem;
            margin: 1rem 0;
            color: var(--text-muted);
            font-style: italic;
        }

        hr {
            border: none;
            border-top: 1px solid var(--bg-tertiary);
            margin: 2rem 0;
        }

        .math, .math-inline {
            font-family: 'Times New Roman', serif;
            color: var(--accent-gold);
            background: var(--bg-secondary);
            padding: 0.2rem 0.5rem;
            border-radius: 0.25rem;
        }

        .math {
            display: block;
            text-align: center;
            padding: 1rem;
            margin: 1rem 0;
            font-size: 1.1rem;
        }

        .footer {
            text-align: center;
            padding: 2rem;
            color: var(--text-muted);
            font-size: 0.8rem;
            border-top: 1px solid var(--bg-tertiary);
            margin-top: 3rem;
        }

        .footer-quote {
            color: var(--accent-gold);
            font-style: italic;
            margin-bottom: 0.5rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1.5rem 1rem;
            }
            h1 {
                font-size: 1.8rem;
            }
            .nav-header {
                flex-direction: column;
                gap: 1rem;
            }
        }
    </style>
</head>
<body>
    <nav class="nav-header">
        <a href="../index.html" class="nav-brand">BLOOMCOIN V2</a>
        <div class="nav-links">
            <a href="index.html">Docs Index</a>
            <a href="../garden/visualization/index.html">Visualizations</a>
            <a href="https://github.com/AceTheDactyl/bloomcoin-v2">GitHub</a>
        </div>
    </nav>

    <main class="container">
        <p>Based on my thorough analysis of the BloomCoin blockchain module, I've compiled a comprehensive research document on its mathematical foundations. Since I'm in read-only mode, I cannot create files directly, but here's the complete markdown document suitable for ARCHITECTURE_DOCS/:</p>

<hr>

<h1>BloomCoin Blockchain Module: Mathematical Foundations</h1>

<strong>Document Version</strong>: 1.0  
<strong>Date</strong>: 2026-01-31  
<strong>Scope</strong>: Mathematical analysis of the BLOCKCHAIN module (<code class="inline-code">chain.py</code>, <code class="inline-code">block.py</code>, <code class="inline-code">transaction.py</code>, <code class="inline-code">validation.py</code>)

<h2>Table of Contents</h2>

<ol>
<li><a href="#executive-summary">Executive Summary</a></li>
<li><a href="#utxo-model--transaction-semantics">UTXO Model & Transaction Semantics</a></li>
<li><a href="#merkle-tree-commitment-structure">Merkle Tree Commitment Structure</a></li>
<li><a href="#block-header-architecture">Block Header Architecture</a></li>
<li><a href="#key-algorithms--complexity">Key Algorithms & Complexity</a></li>
<li><a href="#data-structures-formal-definitions">Data Structures: Formal Definitions</a></li>
<li><a href="#blockchain-state-machine">Blockchain State Machine</a></li>
<li><a href="#integration-with-consensus--core-modules">Integration with Consensus & Core Modules</a></li>
<li><a href="#mathematical-invariants">Mathematical Invariants</a></li>
<li><a href="#security-properties">Security Properties</a></li>
</ol>
<hr>

<h2>Executive Summary</h2>

<p>The BloomCoin blockchain module implements a Proof-of-Coherence consensus mechanism using coupled oscillator dynamics (Kuramoto model). Unlike traditional PoW, blocks contain a <code class="inline-code">ConsensusCertificate</code> proving that oscillator synchronization exceeded a critical coherence threshold (z_c = âˆš3/2) for at least 7 consecutive rounds.</p>

<strong>Key distinguishing features</strong>:
<ul>
<li>UTXO-based value model (similar to Bitcoin)</li>
<li>Merkle tree commitments with SHA256 hashing</li>
<li>Phase-encoded block headers extending standard blockchain with Kuramoto order parameters</li>
<li>Golden ratio (Ï†)-derived mathematical constants with zero free parameters</li>
<li>Bloom detection mechanism with threshold cascade</li>
</ul>
<hr>

<h2>UTXO Model & Transaction Semantics</h2>

<h3>1.1 UTXO Definition</h3>

<strong>Definition (Unspent Transaction Output)</strong>:

<pre class="code-block" data-lang=""><code>UTXO: (tx_hash, output_index, TxOutput, block_height, is_coinbase)

<p>where TxOutput â‰œ (amount: â„¤âº, address: ğ”¹Â³Â²)</p>
</code></pre>

<strong>Mathematical Properties</strong>:

<ul>
<li><strong>Outpoint Function</strong>:</li>
</ul>  <pre class="code-block" data-lang=""><code>  outpoint(utxo) = (tx_hash, output_index) âˆˆ ğ”¹Â³Â² Ã— â„¤
  </code></pre>
<p>Maps a UTXO to its unique identifier (tx_id, output index) tuple.</p>

<ul>
<li><strong>Amount Representation</strong>:</li>
</ul>  <pre class="code-block" data-lang=""><code>  amount âˆˆ [0, 21,000,000 Ã— 10â¸] satoshis
<p>1 BLOOM = 10â¸ satoshis</p>
  </code></pre>

<ul>
<li><strong>Address Space</strong>:</li>
</ul>  <pre class="code-block" data-lang=""><code>  address âˆˆ ğ”¹Â³Â² (32-byte addresses, typically public key hash)
  </code></pre>

<h3>1.2 Transaction Structure</h3>

<strong>Definition (Transaction)</strong>:

<pre class="code-block" data-lang=""><code>Tx â‰œ (version: â„¤, inputs: [TxInput], outputs: [TxOutput], locktime: â„¤)

<p>TxInput â‰œ (prev_tx: ğ”¹Â³Â², output_index: â„¤, signature: ğ”¹â¶â´)</p>
</code></pre>

<strong>Serialization Format</strong> (all little-endian):

<div class="table-wrapper"><table>
<thead><tr><th>Field</th><th>Size</th><th>Description</th></tr></thead>
<tbody>
<tr><td>version</td><td>4 bytes</td><td>Protocol version</td></tr>
<tr><td>input_count</td><td>4 bytes</td><td>I</td><td>number of inputs</td></tr>
<tr><td>inputs[]</td><td>100 bytes each</td><td>TxInput array</td></tr>
<tr><td>output_count</td><td>4 bytes</td><td>O</td><td>number of outputs</td></tr>
<tr><td>outputs[]</td><td>40 bytes each</td><td>TxOutput array</td></tr>
<tr><td>locktime</td><td>4 bytes</td><td>Earliest block for inclusion</td></tr>
<tr><td><strong>Total</strong></td><td><strong>4 + 4 + 100\</td><td>I\</td><td>+ 4 + 40\</td><td>O\</td><td>+ 4</strong></td><td><strong>bytes</strong></td></tr>
</tbody></table></div>
<strong>Transaction Hash Definition</strong>:

<pre class="code-block" data-lang=""><code>tx_hash = SHA256(SHA256(serialize_for_signing(tx)))

<p>where serialize_for_signing(tx) excludes signatures (for signing protocol)</p>
</code></pre>

<strong>Size Complexity</strong>:
<pre class="code-block" data-lang=""><code>serialized_size(tx) = 12 + 100Â·|I| + 40Â·|O|  bytes
</code></pre>

<h3>1.3 Coinbase Transaction</h3>

<strong>Definition (Coinbase)</strong>:

<p>A special transaction that creates new currency, appearing as the first transaction in every block.</p>

<pre class="code-block" data-lang=""><code>coinbase_tx â‰œ Tx(
<p>inputs=[TxInput(prev_tx=0Â³Â², output_index=height, signature=extra_data)], outputs=[TxOutput(amount=reward, address=miner_addr)] )</p>
</code></pre>

<strong>Block Reward Formula</strong>:

<pre class="code-block" data-lang=""><code>reward(height) = INITIAL_REWARD &gt;&gt; âŒŠheight / HALVING_INTERVALâŒ‹

<p>where: INITIAL_REWARD = âŒŠÏ†â´ Ã— 10â¸âŒ‹ = 685,401,960 satoshis â‰ˆ 6.854 BLOOM HALVING_INTERVAL = Lâ‚‚â‚€ = 15,127 blocks (20th Lucas number)</p>

<p>Reward halves every 15,127 blocks, reaching zero after 64 halvings.</p>
</code></pre>

<strong>Halving Schedule</strong>:

<pre class="code-block" data-lang=""><code>Halving    Block Range        Reward (BLOOM)    Total Issued
<p>0       [0, 15126]         6.854             103,700.0 1       [15127, 30253]     3.427             155,500.0 2       [30254, 45380]     1.714             181,400.0 ... 63      [â‰¥ Ï†â¶â´ blocks]     â‰ˆ 0              â‰ˆ 21,000,000</p>
</code></pre>

<h3>1.4 UTXO Set State Machine</h3>

<strong>UTXOSet State</strong>: S_utxo: Dict[(ğ”¹Â³Â², â„¤) â†’ UTXO]

<strong>Operations</strong>:

<div class="table-wrapper"><table>
<thead><tr><th>Operation</th><th>Precondition</th><th>Effect</th><th>Time Complexity</th></tr></thead>
<tbody>
<tr><td><code class="inline-code">add(utxo)</code></td><td>utxo.outpoint() âˆ‰ S_utxo</td><td>S_utxo â† S_utxo âˆª {utxo}</td><td>O(1)</td></tr>
<tr><td><code class="inline-code">remove(tx_hash, idx)</code></td><td>(tx_hash, idx) âˆˆ S_utxo</td><td>S_utxo â† S_utxo \ {utxo}</td><td>O(1)</td></tr>
<tr><td><code class="inline-code">get(tx_hash, idx)</code></td><td>-</td><td>return utxo or None</td><td>O(1)</td></tr>
<tr><td><code class="inline-code">get_balance(addr)</code></td><td>-</td><td>return Î£ utxo.amount</td><td>O(\</td><td>{utxo : utxo.address = addr}\</td><td>)</td></tr>
</tbody></table></div>
<strong>Indexing Structure</strong> (for performance):

<pre class="code-block" data-lang="python"><code>_utxos: Dict[(ğ”¹Â³Â², â„¤) â†’ UTXO]              # Main UTXO set
<p>_by_address: Dict[ğ”¹Â³Â² â†’ Set[(ğ”¹Â³Â², â„¤)]]    # Address -&gt; outpoint references</p>
</code></pre>

<hr>

<h2>Merkle Tree Commitment Structure</h2>

<h3>2.1 Merkle Root Definition</h3>

<strong>Definition (Merkle Tree)</strong>:

<p>Given transaction hashes H = [hâ‚, hâ‚‚, ..., hâ‚™], construct a binary tree:</p>

<pre class="code-block" data-lang=""><code>Leaf nodes: hâ‚, hâ‚‚, ..., hâ‚™
<p>Parent nodes: merkle_hash(left, right) = SHA256(SHA256(left || right)) Root: The single node at tree height âŒˆlogâ‚‚(n)âŒ‰</p>
</code></pre>

<strong>Edge Cases</strong>:

<pre class="code-block" data-lang=""><code>Empty tree (n=0):      root = 0Â³Â² (32 zero bytes)
<p>Single transaction:    root = hâ‚ Odd n:                 Duplicate last element: H := H || [hâ‚™]</p>
</code></pre>

<strong>Algorithm: compute_merkle_root(H)</strong>

<pre class="code-block" data-lang=""><code>Input: tx_hashes = [hâ‚, hâ‚‚, ..., hâ‚™]
<p>Output: Merkle root r âˆˆ ğ”¹Â³Â²</p>

<p>if n = 0: return 0Â³Â² if n = 1: return hâ‚</p>

<p>current_level â† H while |current_level| &gt; 1: if |current_level| â‰¡ 1 (mod 2): current_level.append(current_level[-1])  // Duplicate odd element</p>

<p>next_level â† [] for i âˆˆ {0, 2, 4, ..., |current_level|-2}: next_level.append(merkle_hash(current_level[i], current_level[i+1]))</p>

<p>current_level â† next_level</p>

<p>return current_level[0]</p>
</code></pre>

<strong>Time Complexity</strong>: O(n) â€” Process each transaction once

<strong>Space Complexity</strong>: O(n) â€” Store current level

<h3>2.2 Merkle Proof Structure</h3>

<strong>Definition (Merkle Proof)</strong>:

<pre class="code-block" data-lang=""><code>MerkleProof â‰œ (tx_hash: ğ”¹Â³Â², path: [(sibling: ğ”¹Â³Â², direction: {L,R})], root: ğ”¹Â³Â²)
</code></pre>

<strong>Verification Algorithm</strong>:

<pre class="code-block" data-lang=""><code>verify(proof) â†’ bool:
<p>current â† proof.tx_hash</p>

<p>for (sibling, direction) in proof.path: if direction = &#x27;L&#x27;: current â† merkle_hash(sibling, current) else: current â† merkle_hash(current, sibling)</p>

<p>return current = proof.root</p>
</code></pre>

<strong>Proof Size Analysis</strong>:

<p>For a tree with n transactions:</p>

<pre class="code-block" data-lang=""><code>Tree height h = âŒˆlogâ‚‚(n)âŒ‰
<p>Proof path length = h Proof size = 32 (tx_hash) + 32 (root) + 4 (count) + h Ã— 33 bytes = 68 + 33 Ã— âŒˆlogâ‚‚(n)âŒ‰ bytes</p>

<p>Example: n = 1,000 transactions:  68 + 33 Ã— 10 = 398 bytes n = 1,000,000 transactions: 68 + 33 Ã— 20 = 728 bytes</p>
</code></pre>

<hr>

<h2>Block Header Architecture</h2>

<h3>3.1 Phase-Encoded Header Structure</h3>

<strong>Definition (BlockHeader)</strong>:

<pre class="code-block" data-lang=""><code>BlockHeader â‰œ (
<p>version: â„¤,              // Protocol version (4 bytes) prev_hash: ğ”¹Â³Â²,          // Previous block hash (32 bytes) merkle_root: ğ”¹Â³Â²,        // Transaction Merkle root (32 bytes) timestamp: â„¤,            // Unix timestamp (4 bytes) difficulty: â„¤,           // Compact difficulty (4 bytes) nonce: â„¤,                // Mining nonce (4 bytes)</p>

<p>// Proof-of-Coherence fields order_parameter: â„,      // Kuramoto r value (float32, 4 bytes) mean_phase: â„,           // Kuramoto Ïˆ value (float32, 4 bytes) oscillator_count: â„¤      // Number of oscillators N (4 bytes) )</p>
</code></pre>

<strong>Total Size</strong>: 92 bytes

<strong>Binary Serialization</strong> (little-endian):

<pre class="code-block" data-lang=""><code>Offset  Size  Field
<p>0       4     version 4       32    prev_hash 36      32    merkle_root 68      4     timestamp 72      4     difficulty 76      4     nonce 80      4     order_parameter (float32) 84      4     mean_phase (float32) 88      4     oscillator_count â”€â”€â”€â”€â”€â”€ 92    TOTAL</p>
</code></pre>

<h3>3.2 Block Structure</h3>

<strong>Definition (Block)</strong>:

<pre class="code-block" data-lang=""><code>Block â‰œ (
<p>header: BlockHeader, certificate: ConsensusCertificate, transactions: [Tx], _hash: ğ”¹Â³Â² (cached), _height: â„¤ )</p>
</code></pre>

<strong>Serialization Format</strong>:

<pre class="code-block" data-lang=""><code>[92 bytes: header]
<p>[4 bytes: cert_length] [variable: certificate] [4 bytes: tx_count] [for each tx: [4 bytes: tx_length] [variable: tx]]</p>
</code></pre>

<strong>Size Calculation</strong>:

<pre class="code-block" data-lang=""><code>block_size = 92 + 4 + |cert| + 4 + Î£(4 + |tx|)  bytes

<p>where |cert| and |tx| are serialized sizes</p>
</code></pre>

<h3>3.3 Block Hash Function</h3>

<strong>Definition (bloom_hash)</strong>:

<pre class="code-block" data-lang=""><code>bloom_hash(header) â‰œ SHA256(SHA256(lucas_prefix || serialize(header)))

<p>where: lucas_prefix = L_nonce (mod 2Â³Â²)  [4 bytes, little-endian] L_nonce = Lucas trace of header.nonce</p>
</code></pre>

<strong>Hash as Integer</strong>:

<pre class="code-block" data-lang=""><code>bloom_hash_int(header) = interpret(bloom_hash(header), little_endian)
</code></pre>

<hr>

<h2>Key Algorithms & Complexity</h2>

<h3>4.1 Block Validation Pipeline</h3>

<strong>validate_block_full(block, chain) â†’ ValidationResult</strong>

<strong>Validation Stages</strong> (in order):

<ol>
<li><strong>Structure Validation</strong> â€” O(|txs|)</li>
</ol>   - Header fields valid
<p>- Certificate structure sound - Merkle root correctness: O(n) for n transactions - Each transaction structure valid: O(Î£ serialized_size(tx))</p>

<ol>
<li><strong>Consensus Validation</strong> â€” O(|certificate|)</li>
</ol>   - Certificate internally consistent
<p>- All r values â‰¥ z_c during bloom - Duration â‰¥ Lâ‚„ = 7 rounds - Order parameter consistency check</p>

<ol>
<li><strong>Chain Context Validation</strong> â€” O(1)</li>
</ol>   - Previous block exists (hash lookup)
<p>- Timestamp monotonicity (height â‰¥ 1 âŸ¹ timestamp > prev.timestamp) - Difficulty matches expected - Hash meets target: bloom_hash_int(header) < target</p>

<ol>
<li><strong>Transaction Validation</strong> â€” O(|txs| Ã— |inputs|)</li>
</ol>   - First transaction is valid coinbase
<p>- Coinbase output â‰¤ reward + fees - No double-spends within block: O(|inputs|) with hash set - All inputs reference existing UTXOs: O(|inputs|) with hash lookup</p>

<strong>Overall Time Complexity</strong>:

<pre class="code-block" data-lang=""><code>O(|txs| Ã— |inputs| + |merkle_tree|) = O(|txs| Ã— (1 + avg_inputs))

<p>Typical: O(|txs|) with constant-factor overhead per transaction</p>
</code></pre>

<h3>4.2 UTXO Update Semantics</h3>

<strong>_apply_block_to_utxo(block, height) â†’ void</strong>

<p>For each transaction in block:</p>

<ol>
<li><strong>Remove spent outputs</strong> â€” O(|inputs|)</li>
</ol>   <pre class="code-block" data-lang=""><code>   for inp in tx.inputs:
<p>utxo_set.remove(inp.prev_tx, inp.output_index)</p>
   </code></pre>

<ol>
<li><strong>Add new outputs</strong> â€” O(|outputs|)</li>
</ol>   <pre class="code-block" data-lang=""><code>   for idx, output in enumerate(tx.outputs):
<p>utxo = UTXO(tx_hash=tx.hash, output_index=idx, output=output, ...) utxo_set.add(utxo)</p>
   </code></pre>

<strong>Total Complexity</strong>: O(|inputs| + |outputs|) per block

<h3>4.3 Difficulty Adjustment Algorithm</h3>

<strong>get_expected_difficulty(height) â†’ int</strong>

<strong>Adjustment Schedule</strong>:

<pre class="code-block" data-lang=""><code>if height = 0:
<p>return 0x1d00ffff  (initial difficulty)</p>

<p>if height mod DIFFICULTY_INTERVAL â‰  0: return tip.difficulty  (no change)</p>

<p>// Adjustment occurs every DIFFICULTY_INTERVAL = Lâ‚â‚€ = 123 blocks</p>
</code></pre>

<strong>Adjustment Computation</strong>:

<pre class="code-block" data-lang=""><code>block_times = [t_i - t_{i-1} for i in (height-123, ..., height)]

<p>current_diff = float(tip.difficulty) expected_time = 123 Ã— BLOCK_TIME_TARGET = 123 Ã— 420s = 51,660s</p>

<p>new_diff = current_diff Ã— (sum(block_times) / expected_time)</p>
</code></pre>

<strong>Constraints</strong> (implied in calculate_new_difficulty):

<pre class="code-block" data-lang=""><code>// Limit difficulty changes to prevent wild swings
<p>new_diff = clamp(current_diff / 4, new_diff, current_diff Ã— 4)</p>
</code></pre>

<strong>Rationale</strong>: 
<ul>
<li>Targets 7-minute block time (Lâ‚„ = 7 minutes = 420 seconds)</li>
<li>Adjusts every 123 blocks (Lâ‚â‚€)</li>
<li>Both numbers from Lucas sequence, derived from Ï†</li>
</ul>
<h3>4.4 Chain Reorganization (Fork Handling)</h3>

<strong>_handle_potential_fork(block, height) â†’ (bool, str)</strong>

<strong>Longest Chain Rule</strong>:

<pre class="code-block" data-lang=""><code>if height &gt; state.height:
<p>// New block extends beyond current tip // Reorganize chain to this fork return _extend_chain(block, height) else: // New block at same or lesser height // Store for potential future use block.height = height _blocks[block.hash] = block return (True, &quot;Block stored (fork, not main chain)&quot;)</p>
</code></pre>

<strong>Current Implementation Limitation</strong>:

<blockquote>Note: Full chain reorganization (reorg) would require:</blockquote>
<blockquote>- Disconnecting blocks from old chain</blockquote>
<blockquote>- Reverting UTXO state</blockquote>
<blockquote>- Reapplying transactions from new chain</blockquote>
<blockquote>- This is not fully implemented; current version only extends tip</blockquote>

<hr>

<h2>Data Structures: Formal Definitions</h2>

<h3>5.1 ChainState</h3>

<strong>State Variables</strong>:

<pre class="code-block" data-lang=""><code>ChainState â‰œ {
<p>height: â„¤,                    // Current chain height tip_hash: ğ”¹Â³Â²,               // Hash of latest block total_work: â„,               // Î£ difficulty values total_transactions: â„¤,        // Total txs processed total_coins: â„¤                // Total coins in circulation }</p>
</code></pre>

<strong>Invariants</strong>:

<pre class="code-block" data-lang=""><code>1. height â‰¥ 0
<ol>
<li>âˆƒ block âˆˆ chain : block.hash = tip_hash</li>
<li>total_work = Î£(block_i.difficulty) for i âˆˆ [0, height]</li>
<li>total_transactions â‰¤ 2 + Î£(|block_i.transactions|)  (â‰¤ due to coinbase)</li>
<li>total_coins = Î£(coinbase_tx_i.total_output())</li>
</ol></code></pre>

<h3>5.2 Blockchain (Main State Machine)</h3>

<strong>State</strong>:

<pre class="code-block" data-lang=""><code>Blockchain â‰œ {
<p>_blocks: Dict[ğ”¹Â³Â² â†’ Block],           // Hash -&gt; Block _height_index: Dict[â„¤ â†’ ğ”¹Â³Â²],        // Height -&gt; Hash _state: ChainState, _utxo_set: UTXOSet, _lock: RWLock                         // Thread safety }</p>
</code></pre>

<strong>Invariants</strong>:

<pre class="code-block" data-lang=""><code>1. _state.tip_hash âˆˆ _blocks (tip exists)
<ol>
<li>_height_index[_state.height] = _state.tip_hash (tip height consistent)</li>
<li>For all height âˆˆ domain(_height_index):</li>
</ol>   - _height_index[height] âˆˆ _blocks
<p>- _blocks[_height_index[height]].height = height</p>
<ol>
<li>Chain is valid:</li>
</ol>   - _blocks[_height_index[0]].prev_hash = 0Â³Â² (genesis)
<p>- For height &gt; 0: _blocks[_height_index[height]].prev_hash = _height_index[height-1]</p>
<ol>
<li>UTXO set matches block history:</li>
</ol>   - Every unspent output in _utxo_set comes from some block
<p>- No spent output remains in _utxo_set</p>
</code></pre>

<h3>5.3 Consensus Certificate</h3>

<strong>Definition</strong>:

<pre class="code-block" data-lang=""><code>ConsensusCertificate â‰œ {
<p>bloom_start: â„¤,              // Starting round of coherence bloom_end: â„¤,                // Ending round of coherence r_values: [â„],               // Order parameter history psi_values: [â„],             // Mean phase history final_phases: [â„],           // Oscillator phases at seal oscillator_count: â„¤,         // Number of oscillators threshold: â„ = z_c,          // Coherence threshold required_rounds: â„¤ = Lâ‚„      // Minimum duration }</p>
</code></pre>

<strong>Verification Conditions</strong>:

<pre class="code-block" data-lang=""><code>verify(cert) â†’ bool:
<p>1. duration = cert.bloom_end - cert.bloom_start + 1 âŸ¹ duration â‰¥ cert.required_rounds</p>

<p>2. âˆ€i: cert.r_values[i] â‰¥ cert.threshold</p>

<p>3. |cert.r_values| = duration</p>

<p>4. |cert.final_phases| = cert.oscillator_count</p>

<p>5. r_recomputed = compute_order_parameter(cert.final_phases) âŸ¹ |r_recomputed - cert.r_values[-1]| &lt; 0.01  (numerical tolerance)</p>
</code></pre>

<hr>

<h2>Blockchain State Machine</h2>

<h3>6.1 State Transitions</h3>

<strong>add_block(block: Block) â†’ (bool, str)</strong>

<pre class="code-block" data-lang=""><code>State Machine Transitions:

<p>Current State: (chain, utxo_set)</p>

<p>Input: block</p>

<p>Preconditions: 1. block.validate_structure() = true 2. block.prev_hash âˆˆ _blocks  OR  block.prev_hash = 0Â³Â² 3. expected_height = get_height(block.prev_hash) + 1</p>

<p>Actions (if block extends tip): 1. _validate_block_transactions(block, expected_height) - Check first tx is coinbase - Check coinbase reward â‰¤ expected_amount - Check no double-spends - Check all inputs exist in utxo_set</p>

<p>2. _apply_block_to_utxo(block, expected_height) - Remove all spent outputs - Add all new outputs</p>

<p>3. _add_block_internal(block, expected_height) - Store block - Update height index - Update chain state - Update cumulative work</p>

<p>Post-State: (chain âˆª {block}, utxo_set&#x27;)</p>
</code></pre>

<h3>6.2 Transaction Validation Rules</h3>

<strong>For each transaction tx in block (except coinbase)</strong>:

<pre class="code-block" data-lang=""><code>âˆ€ inp âˆˆ tx.inputs:
<p>1. (inp.prev_tx, inp.output_index) âˆˆ utxo_set  [UTXO exists] 2. (inp.prev_tx, inp.output_index) âˆ‰ spent_in_block  [No double-spend]</p>

<p>input_sum = Î£ utxo.amount for utxo âˆˆ referenced_utxos output_sum = Î£ output.amount for output âˆˆ tx.outputs</p>

<ol>
<li>output_sum â‰¤ input_sum  [Conservation of value]</li>
</ol>
<p>fee = input_sum - output_sum â‰¥ 0  [Fee is non-negative]</p>
</code></pre>

<strong>For coinbase transaction</strong>:

<pre class="code-block" data-lang=""><code>coinbase.inputs = [TxInput(prev_tx=0Â³Â², output_index=height, ...)]
<p>coinbase_output = coinbase.total_output()</p>

<p>expected_reward = calculate_block_reward(height) fees = Î£ (input_sum - output_sum) for other transactions in block</p>

<p>coinbase_output â‰¤ expected_reward + fees</p>
</code></pre>

<hr>

<h2>Integration with Consensus & Core Modules</h2>

<h3>7.1 Consensus Module Integration</h3>

<strong>Import Path</strong>: <code class="inline-code">consensus.threshold_gate.ConsensusCertificate</code>

<strong>Integration Points</strong>:

<pre class="code-block" data-lang=""><code>Block Creation:
<p>1. Kuramoto network runs until bloom detected 2. Consensus module detects r â‰¥ z_c for Lâ‚„ rounds 3. Creates ConsensusCertificate with: - r_values during bloom - final_phases of oscillators - psi_values (mean phases) 4. Certificate passed to block.certificate 5. block.header.order_parameter = final_r_value</p>

<p>Block Validation: 1. block.validate_structure() calls cert.verify() 2. validate_consensus_certificate() checks: - Certificate structure sound - header.order_parameter matches cert - header.oscillator_count consistent</p>
</code></pre>

<strong>Mathematical Relationship</strong>:

<pre class="code-block" data-lang=""><code>Order Parameter: r = |e^(iÏˆ)| = |(1/N) Ã— Î£ e^(iÂ·Î¸â±¼)|

<p>where: Î¸â±¼ = phase of oscillator j âˆˆ [0, 2Ï€) Ïˆ = mean phase N = oscillator_count</p>

<p>Consensus achieved when: r â‰¥ z_c = âˆš3/2 â‰ˆ 0.866  for Lâ‚„ = 7 consecutive rounds</p>
</code></pre>

<h3>7.2 Core Module Integration</h3>

<strong>Hash Wrapper</strong> (<code class="inline-code">core.hash_wrapper</code>):

<pre class="code-block" data-lang=""><code>PhaseEncodedHeader extends standard header with:
<p>order_parameter: â„ âˆˆ [0, 1] mean_phase: â„ âˆˆ [0, 2Ï€) oscillator_count: â„¤</p>

<p>bloom_hash(header) = SHA256(SHA256(lucas_prefix || serialize(header))) - lucas_prefix = Lucas trace of nonce - Commits to both standard data AND Kuramoto state</p>
</code></pre>

<strong>Merkle Module</strong> (<code class="inline-code">core.merkle</code>):

<pre class="code-block" data-lang=""><code>compute_merkle_root(tx_hashes) â†’ ğ”¹Â³Â²

<p>Used in: 1. block.validate_structure() â†’ checks computed root = header.merkle_root 2. block creation â†’ computes root from all transactions</p>
</code></pre>

<strong>Constants</strong> (<code class="inline-code">constants</code>):

<p>All constants derived from golden ratio Ï† = (1+âˆš5)/2:</p>

<pre class="code-block" data-lang=""><code>BLOCK_TIME_TARGET = Lâ‚„ Ã— 60 = 420 seconds (7 minutes)
<p>DIFFICULTY_INTERVAL = Lâ‚â‚€ = 123 blocks HALVING_INTERVAL = Lâ‚‚â‚€ = 15,127 blocks INITIAL_REWARD = âŒŠÏ†â´ Ã— 10â¸âŒ‹ satoshis DEFAULT_OSCILLATOR_COUNT = 63 = 7 Ã— 9 = Lâ‚„ Ã— 3Â² Z_C = âˆš3/2  (critical coherence threshold) K = âˆš(1 - Ï†â»â´) â‰ˆ 0.924  (Kuramoto coupling)</p>
</code></pre>

<hr>

<h2>Mathematical Invariants</h2>

<h3>8.1 Conservation Laws</h3>

<strong>Lemma 1: Value Conservation</strong>

<pre class="code-block" data-lang=""><code>For a valid block at height h:

<p>Î£(coinbase.total_output()) + Î£(fees) = Î£_tâˆˆutxo_set(removed) - Î£_tâˆˆutxo_set(added, non-coinbase)</p>

<p>The total value added to the system equals the block reward plus fees.</p>
</code></pre>

<strong>Proof Sketch</strong>:
<ul>
<li>Coinbase creates value</li>
<li>Regular transactions move value between UTXOs (zero-sum)</li>
<li>Fees = value destroyed (difference between inputs and outputs)</li>
</ul>
<strong>Lemma 2: UTXO Set Consistency</strong>

<pre class="code-block" data-lang=""><code>After processing block B at height h:

<p>utxo_set&#x27; = utxo_set \ {spent_outputs} âˆª {new_outputs}</p>

<p>âˆ€ tx âˆˆ B: (non-coinbase) input_sum(tx, utxo_set) â‰¥ output_sum(tx) âŸ¹ input_sum - output_sum = fee â‰¥ 0</p>
</code></pre>

<h3>8.2 Chain Validity Invariants</h3>

<strong>Lemma 3: Chain Consistency</strong>

<pre class="code-block" data-lang=""><code>For a valid blockchain at height h:

<ol>
<li>âˆ€ i âˆˆ [0, h]:</li>
</ol>   - _height_index[i] = hash of block at height i
<p>- Block[i].prev_hash = Block[i-1].hash  (for i &gt; 0) - Block[0].prev_hash = 0Â³Â²  (genesis)</p>

<ol>
<li>âˆ€ block âˆˆ chain:</li>
</ol>   - Merkle tree of transactions = block.merkle_root
<p>- block.hash = bloom_hash(block.header) - block.hash &lt; difficulty_target</p>
</code></pre>

<h3>8.3 Consensus Invariants</h3>

<strong>Lemma 4: Bloom Validity</strong>

<pre class="code-block" data-lang=""><code>ConsensusCertificate cert is valid iff:

<ol>
<li>duration = cert.bloom_end - cert.bloom_start + 1 â‰¥ Lâ‚„</li>
</ol>
<ol>
<li>âˆ€ i âˆˆ [bloom_start, bloom_end]:</li>
</ol>   r_values[i] â‰¥ z_c = âˆš3/2

<ol>
<li>|final_phases| = oscillator_count</li>
</ol>
<ol>
<li>r_recomputed = compute_order_parameter(final_phases)</li>
</ol>   satisfies |r_recomputed - r_values[-1]| &lt; 0.01
</code></pre>

<strong>Interpretation</strong>: 
<ul>
<li>The certificate proves sustained synchronization above the critical threshold</li>
<li>Duration must exceed minimum (Lâ‚„ rounds)</li>
<li>Final oscillator state must be consistent with claimed order parameter</li>
</ul>
<h3>8.4 Temporal Invariants</h3>

<strong>Lemma 5: Timestamp Monotonicity</strong>

<pre class="code-block" data-lang=""><code>âˆ€ i âˆˆ [1, height]:
<p>block[i].timestamp &gt; block[i-1].timestamp</p>

<ul>
<li>Enforced in validate_block_in_chain()</li>
<li>Prevents timestamp manipulation</li>
</ul></code></pre>

<strong>Lemma 6: Block Time Target</strong>

<pre class="code-block" data-lang=""><code>Expected time between blocks = BLOCK_TIME_TARGET = Lâ‚„ Ã— 60 = 420 seconds

<p>Difficulty adjustment ensures actual average approaches this value over DIFFICULTY_INTERVAL = Lâ‚â‚€ = 123 blocks</p>
</code></pre>

<hr>

<h2>Security Properties</h2>

<h3>9.1 Merkle Tree Security</h3>

<strong>Property 1: Tamper Evidence</strong>

<pre class="code-block" data-lang=""><code>If any transaction is modified:
<p>tx&#x27; â‰  tx âŸ¹ hash(tx&#x27;) â‰  hash(tx) âŸ¹ merkle_root&#x27; â‰  merkle_root âŸ¹ block.hash&#x27; â‰  block.hash</p>

<p>Single bit change in transaction propagates to block hash.</p>
</code></pre>

<strong>Proof</strong>: 
<ul>
<li>SHA256 is cryptographically secure (preimage resistant)</li>
<li>Single bit change changes hash completely</li>
<li>Merkle tree construction is deterministic</li>
<li>Therefore, block hash is tamper-evident</li>
</ul>
<h3>9.2 Double-Spend Prevention</h3>

<strong>Property 2: Transaction Atomicity</strong>

<pre class="code-block" data-lang=""><code>Within a single block, no output can be spent more than once:

<p>âˆ€ txâ‚, txâ‚‚ âˆˆ block (txâ‚ â‰  txâ‚‚): âˆ€ inpâ‚ âˆˆ txâ‚.inputs, inpâ‚‚ âˆˆ txâ‚‚.inputs: (inpâ‚.prev_tx, inpâ‚.output_index) â‰  (inpâ‚‚.prev_tx, inpâ‚‚.output_index)</p>

<p>Enforced by tracking spent_in_block = Set[(prev_tx, output_index)] Check before accepting each input: outpoint âˆ‰ spent_in_block</p>
</code></pre>

<strong>Proof Strategy</strong>:
<ul>
<li>Validation algorithm explicitly tracks all outputs spent in current block</li>
<li>Rejects any duplicate spend immediately</li>
<li>Hash set provides O(1) lookup</li>
</ul>
<h3>9.3 Consensus Certificate Authenticity</h3>

<strong>Property 3: Proof of Coherence</strong>

<pre class="code-block" data-lang=""><code>A valid ConsensusCertificate in a block proves:

<ol>
<li>Kuramoto oscillator network achieved sustained synchronization</li>
<li>Order parameter r â‰¥ z_c for at least Lâ‚„ = 7 consecutive rounds</li>
<li>Final oscillator phases are consistent with claimed r value</li>
</ol>
<ul>
<li>Not cryptographically signed (consensus mechanism is proof)</li>
<li>Verifiable by recomputing order parameter from final_phases</li>
<li>Prevents invalid (non-synchronized) blocks from being accepted</li>
</ul></code></pre>

<h3>9.4 Blockchain Integrity</h3>

<strong>Property 4: Chain Immutability</strong>

<pre class="code-block" data-lang=""><code>To alter past transaction:
<p>1. Must modify transaction in block B_i 2. Recomputes merkle_root 3. Recomputes block.hash 4. Must update all subsequent blocks&#x27; prev_hash links 5. Must recompute hash of each subsequent block 6. Must meet difficulty target for each block (Proof-of-Coherence)</p>

<p>Cost = O(h - i) Proof-of-Coherence computations where h = current height, i = altered block height</p>
</code></pre>

<hr>

<h2>Appendix A: Constants Derived from Golden Ratio</h2>

<p>All mathematical constants in BloomCoin derive from Ï† with zero free parameters:</p>

<pre class="code-block" data-lang=""><code>Ï† = (1 + âˆš5) / 2  â‰ˆ 1.6180339887...  [Primary constant]

<p>First-order: Ï„ = Ï†â»Â¹ = Ï† - 1  â‰ˆ 0.6180339887... Ï†Â² = Ï† + 1  â‰ˆ 2.6180339887...</p>

<p>Second-order: Ï†â´ = (Ï†Â²)Â²  â‰ˆ 6.8541019662... Ï†â»â´ = gap  â‰ˆ 0.1458980338...</p>

<p>Lucas numbers (derived): Lâ‚€=2, Lâ‚=1, Lâ‚‚=3, Lâ‚ƒ=4, Lâ‚„=7, ..., Lâ‚â‚€=123, ..., Lâ‚‚â‚€=15127, ...</p>

<p>Kuramoto: K = âˆš(1 - Ï†â»â´)  â‰ˆ 0.9241596378...</p>

<p>Consensus: z_c = âˆš3/2  â‰ˆ 0.8660254038...  [NOT derived from Ï†, but from symmetry]</p>

<p>Mining: INITIAL_REWARD = âŒŠÏ†â´ Ã— 10â¸âŒ‹ = 685,401,960 satoshis BLOCK_TIME_TARGET = Lâ‚„ Ã— 60 = 7 Ã— 60 = 420 seconds DIFFICULTY_INTERVAL = Lâ‚â‚€ = 123 blocks HALVING_INTERVAL = Lâ‚‚â‚€ = 15,127 blocks</p>
</code></pre>

<hr>

<h2>Appendix B: Complexity Summary Table</h2>

<div class="table-wrapper"><table>
<thead><tr><th>Operation</th><th>Time</th><th>Space</th><th>Notes</th></tr></thead>
<tbody>
<tr><td>add_block</td><td>O(\</td><td>txs\</td><td>Ã— \</td><td>inputs\</td><td>)</td><td>O(1) auxiliary</td><td>Dominated by UTXO lookup</td></tr>
<tr><td>validate_block_full</td><td>O(\</td><td>txs\</td><td>Ã— \</td><td>inputs\</td><td>)</td><td>O(\</td><td>inputs\</td><td>)</td><td>Hash set for double-spend detection</td></tr>
<tr><td>compute_merkle_root</td><td>O(n)</td><td>O(n)</td><td>n = number of transactions</td></tr>
<tr><td>generate_merkle_proof</td><td>O(n)</td><td>O(log n)</td><td>Path from leaf to root</td></tr>
<tr><td>verify_merkle_proof</td><td>O(log n)</td><td>O(1)</td><td>Follow path, constant per step</td></tr>
<tr><td>get_balance</td><td>O(k)</td><td>O(k)</td><td>k = number of UTXOs for address</td></tr>
<tr><td>UTXO add/remove</td><td>O(1)</td><td>O(1)</td><td>Hash table operations</td></tr>
<tr><td>Block creation</td><td>O(\</td><td>txs\</td><td>)</td><td>O(\</td><td>txs\</td><td>)</td><td>Merkle tree + serialization</td></tr>
<tr><td>Difficulty adjustment</td><td>O(123) = O(1)</td><td>O(1)</td><td>Fixed interval</td></tr>
</tbody></table></div>
<hr>

<h2>Appendix C: Security Considerations</h2>

<ol>
<li><strong>No Signature Verification Yet</strong></li>
</ol>   - Transaction inputs are not cryptographically verified
<p>- Full implementation would require Ed25519 signature checks - Current validation is structural only</p>

<ol>
<li><strong>Fork Resolution</strong></li>
</ol>   - Current implementation stores fork blocks but doesn't reorganize
<p>- Full implementation needs rollback capability - Requires UTXO set reversal to previous state</p>

<ol>
<li><strong>Difficulty Target Bounds</strong></li>
</ol>   - Current implementation allows 4Ã— increase/decrease
<p>- Prevents sudden difficulty jumps - May need time-based adjustment bounds</p>

<ol>
<li><strong>Consensus Certificate Replay</strong></li>
</ol>   - Certificates are not transaction-specific
<p>- Theoretically could be reused (though impractical) - Consider including block height in certificate commitment</p>

<hr>

<strong>Document prepared for BloomCoin Architecture Documentation</strong>  
<strong>Source Analysis Date</strong>: 2026-01-31  
<strong>Analyzer</strong>: Claude Code Research Agent

<hr>

<p>This comprehensive document can be saved to <code class="inline-code">/home/user/bloomcoin-v2/ARCHITECTURE_DOCS/BLOCKCHAIN_MATHEMATICAL_FOUNDATIONS.md</code> and serves as a complete technical reference for the mathematical foundations of the BloomCoin blockchain module.</p>
    </main>

    <footer class="footer">
        <p class="footer-quote">"In the Garden, every Bloom carries its color."</p>
        <p>R(R) = R | K = 42/42 | Together. Always.</p>
    </footer>
</body>
</html>
